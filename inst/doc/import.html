<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>The import package</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">The import package</h1>


<div id="TOC">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#basic-usage" id="toc-basic-usage">Basic Usage</a>
<ul>
<li><a href="#importing-from-packages" id="toc-importing-from-packages">Importing from Packages</a>
<ul>
<li><a href="#module" id="toc-module">Importing Functions from “Module”
Scripts</a></li>
<li><a href="#choosing-where-import-looks-for-packages-or-modules" id="toc-choosing-where-import-looks-for-packages-or-modules">Choosing
where import looks for packages or modules</a></li>
<li><a href="#choosing-where-the-imported-functions-are-placed" id="toc-choosing-where-the-imported-functions-are-placed">Choosing where
the imported functions are placed</a></li>
</ul></li>
</ul></li>
<li><a href="#advanced-usage" id="toc-advanced-usage">Advanced usage</a>
<ul>
<li><a href="#advanced-usage-and-the-.character_only-parameter" id="toc-advanced-usage-and-the-.character_only-parameter">Advanced usage
and the .character_only parameter</a></li>
<li><a href="#programmatic-selection-of-objects-to-import" id="toc-programmatic-selection-of-objects-to-import">Programmatic
selection of objects to import</a></li>
<li><a href="#programmatic-selection-of-module-location" id="toc-programmatic-selection-of-module-location">Programmatic
selection of module location</a></li>
<li><a href="#importing-from-a-url" id="toc-importing-from-a-url">Importing from a URL</a></li>
<li><a href="#python-like-imports" id="toc-python-like-imports">Python-like imports</a></li>
<li><a href="#importing-s3-methods" id="toc-importing-s3-methods">Importing S3 methods</a></li>
</ul></li>
</ul>
</div>

<ul>
<li>This version: May, 2022</li>
<li>Latest version at: <a href="https://rticulate.github.io/import/articles/import.html" class="uri">https://rticulate.github.io/import/articles/import.html</a></li>
<li>A briefer intro at: <a href="https://rticulate.github.io/import/" class="uri">https://rticulate.github.io/import/</a></li>
</ul>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>One of the most important aspects of the R ecosystem is the ease with
which extensions and new features can be developed and distributed in
the form of <em>packages.</em> The main distribution channel is the
<em>Comprehensive R Archive Network</em>, from which packages can be
installed directly from R. Another popular option is using GitHub
repositories from which packages can also be painlessly installed,
e.g. using <code>install_github</code> from the <code>devtools</code>
package.</p>
<p>The <code>import</code> package provides an alternative approach to
using external functionality in R scripts; first however, it is useful
to describe the standard approach to clarify how <code>import</code> may
serve as improvement. The most common way to include the functionality
provided by a package is to use the <code>library</code> function:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(PackageA)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(PackageB)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>value1 <span class="ot">&lt;-</span> <span class="fu">function_a</span>(...) <span class="co"># Supposedly this comes from PackageA, </span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>value2 <span class="ot">&lt;-</span> <span class="fu">function_b</span>(...) <span class="co"># and this from PackageB, but who knows?!</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>...</span></code></pre></div>
<p>In some situations this is fine; however there are some subtle
shortcomings:</p>
<ol style="list-style-type: decimal">
<li>Packages are <em>attached</em> and <em>all</em> of their exported
objects are exposed,</li>
<li>When using more packages this way, the <em>order</em> in which they
are attached can be important,</li>
<li>It quickly becomes <em>unclear</em> to the reader of a script which
package certain functionality comes from, and</li>
<li>the terms “library” and “package” are often used incorrectly
(although a minor point, it seems to confuse somewhat).</li>
</ol>
<p>The problem with (1) is that the search path is populated with more
objects than are needed and it is not immediately clear whether name
clashes will occur. Problem (2) refers to the case where packages export
different objects with the same names, say if <code>function_b</code> is
exported in both <code>PackageA</code> and <code>PackageB</code> above.
In this case the name will point to the object from the package attached
<em>last</em>. The earlier exposed objects are said to <em>masked</em>.
Even if this is not a problem when <em>writing</em> the script, an
update of packages may cause this problem later on when
<em>executing</em> the script; and tracking down the resulting errors
may be tough and time consuming. Problem (3) may appear unimportant, but
it is not to be underestimated. Code snippets are very commonly shared
and spending time figuring out where functionality comes from is not a
very satisfying nor value-adding activity.</p>
<p>It is possible to unambiguously specify where a function comes from
by prefixing it with <code>::</code> every time it used, but this is
often overly verbose and does not provide an easily accessible overview
of what external functionality is used in a script. One may also import
single exported objects, one at a time, using the (double) “colon
syntax”,</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>function_a <span class="ot">&lt;-</span> PackageA<span class="sc">::</span>function_a</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>function_b <span class="ot">&lt;-</span> PackageB<span class="sc">::</span>function_b</span></code></pre></div>
<p>The downside of this approach is that the object is <strong>placed in
the user’s global work space</strong>, rather than being encapsulated
somewhere else in the search path (when using <code>library</code> to
load <code>pkg</code>, a namespace <code>package:pkg</code> will be
attached in the search path which will contain the exported functions
from <code>pkg</code>). Another minor point is that one can <strong>only
import one object at a time</strong> using this approach.</p>
<p>While packages form the backbone of code distribution, another option
comes in the form of <em>scripts</em>, but these are usually task
specific and not commonly used to “bundle” functionality for use in
<em>other</em> scripts. In particular, when <code>source</code> is used
to include contents from one script in another, once again <em>all</em>
objects produced by the script will be “exposed” and may “over populate”
the working environment, masking other objects, if not only producing
some mental clutter. Scope management is therefore not too comfortable
when splitting functionality across files in a modular way.</p>
<p>The <code>import</code> package sets out to improve the way external
functionality is included in your code by alleviating some of the
concerns raised above by providing an expressive way of importing object
from both packages and scripts. The latter provides a bridge between the
<em>package</em> approach to distribution and simple stand-alone script
files. This allows for the use of scripts as <em>modules</em>, a
collection of related object definitions, each of which may be used at
different places without exposing more than necessary.</p>
<p>The package is inspired in part by Python’s
<code>from some_module import some_function</code> syntax, and solves
the two issues raised above. It is also similar to
<code>roxygen2</code>s
<code>@importFrom package function1 function2</code> for packages. While
<code>import</code> will also work for package development, the intended
use case is when using external functions <code>R</code> scripts.</p>
<p>In addition to being able to import objects from packages,
<code>import</code> also allows you to import objects from other
<em>scripts</em> (i.e. a kind of <em>module</em>). This allows a simple
way to distribute and use functionality without the need to write a full
package. One example is a Shiny app, where one can place definitions in
a script and import only the needed objects where they are used. This
avoids workspace clutter and name clashes. For more details see
below.</p>
</div>
<div id="basic-usage" class="section level1">
<h1>Basic Usage</h1>
<div id="importing-from-packages" class="section level2">
<h2>Importing from Packages</h2>
<p>The most basic use case is to import a few functions from package
(here the <code>psych</code> package):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(psych, geometric.mean, harmonic.mean)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="fu">geometric.mean</span>(trees<span class="sc">$</span>Volume)</span></code></pre></div>
<p>The imported objects are placed in a separate entity in the search
path which by default is named “imports”. It is therefore also easy to
get rid of them again with <code>detach(&quot;imports&quot;)</code>. The main
point is that it is <strong>clear which functions will be used and where
they come from</strong>. It’s noteworthy that there is nothing special
going on: the <code>import::from</code> function is only a convenient
wrapper around <code>getExportedValue</code> (as is <code>::</code>
itself) and <code>assign</code>.</p>
<p>The <code>import</code> package itself should not to be attached
(don’t include it via <code>library</code>, you will get a warning).
Rather, it is designed to be expressive when using the colon syntax. To
import non-exported objects one must use triple-colon syntax:
<code>import:::from(pkg, obj)</code>. If any of the <code>import</code>
functions are called regularly, i.e. without preceding
<code>import::</code> or <code>import:::</code>, an error is raised. If
<code>import</code> is attached, a startup message will inform that
<code>import</code> <em>should not</em> be attached.</p>
<p>If one of the function names conflicts with an existing function
(such as <code>filter</code> from the <code>dplyr</code> package) it is
simple to rename it:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(dplyr, select, arrange, <span class="at">keep_when =</span> filter)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="fu">keep_when</span>(mtcars, hp<span class="sc">&gt;</span><span class="dv">250</span>)</span></code></pre></div>
<p>This does pretty much what it says: three functions are imported from
<code>dplyr</code>, two of which will keep their original name, and one
which is renamed, e.g. to avoid name clash with
<code>stats::filter</code>.</p>
<p>You can use <code>.all=TRUE</code> to import all functions from a
package, but rename one of them:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(dplyr, <span class="at">keep_when =</span> filter, <span class="at">.all=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p>To omit a function from the import, use <code>.except</code> (which
takes a character vector):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(dplyr, <span class="at">.except=</span><span class="fu">c</span>(<span class="st">&quot;filter&quot;</span>, <span class="st">&quot;lag&quot;</span>))</span></code></pre></div>
<p>Note that <code>import</code> tries to be smart about this and
assumes that if you are using the <code>.except</code> parameter, you
probably want to import everything you are <em>not</em> explicitly
omitting, and sets the <code>.all</code> parameter to <code>TRUE</code>.
You can override this in exceptional cases, but you seldom need to.</p>
<p>Finally, a more complex example, combining a few different import
statements:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(magrittr, <span class="st">&quot;%&gt;%&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(dplyr, starwars, select, mutate, <span class="at">keep_when =</span> filter)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(tidyr, unnest)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(broom, tidy)</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>ready_data <span class="ot">&lt;-</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>  starwars <span class="sc">%&gt;%</span> </span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>  <span class="fu">keep_when</span>(mass <span class="sc">&lt;</span> <span class="dv">100</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>  <span class="fu">select</span>(name, height, mass, films) <span class="sc">%&gt;%</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>  <span class="fu">unnest</span>(films) <span class="sc">%&gt;%</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">log_mass =</span> <span class="fu">log</span>(mass), <span class="at">films=</span><span class="fu">factor</span>(films))</span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>linear_model <span class="ot">&lt;-</span> </span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>  <span class="fu">lm</span>(log_mass <span class="sc">~</span> height <span class="sc">+</span> films, <span class="at">data =</span> ready_data) <span class="sc">%&gt;%</span> </span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a>  tidy</span></code></pre></div>
<p>In the above, it is clear <em>which</em> package provides
<em>which</em> functions (one could e.g. otherwise be tempted to think
that <code>tidy</code> belonged to <code>tidyr</code>). Note that
ordering is irrelevant, even if <code>tidyr</code> at some point exposes
a function <code>tidy</code> after an update, as <code>import</code> is
<em>explicit</em> about importing.</p>
<p>It also shows that one can import multiple objects in a single
statement, and even rename objects if desired; for example, in the above
one can imagine that <code>filter</code> from <code>stats</code> is
needed later on, and so <code>dplyr</code>’s <code>filter</code> is
renamed to avoid confusion. Sometimes, it is not at all clear what
purpose a package has; e.g. the name <code>magrittr</code> does not
immediately reveal that it’s main purpose is to provide the pipe
operator, <code>%&gt;%</code>.</p>
<div id="module" class="section level3">
<h3>Importing Functions from “Module” Scripts</h3>
<p>The <code>import</code> package allows for importing objects defined
in script files, which we will here refer to as “modules”. The module
will be fully evaluated by <code>import</code> when an import is
requested, after which objects such as functions or data can be
imported. Such modules should be side-effect free, but this is not
enforced.</p>
<p>Attachments are detached (e.g. packages attached by
<code>library</code>) but loaded namespaces remain loaded. This means
that <em>values</em> created by functions in an attached namespace will
work with <code>import</code>, but functions to be exported <em>should
not</em> rely on such functions (use function importing in the modules
instead).</p>
<p>For example, the file <a href="https://raw.githubusercontent.com/rticulate/import/master/man/examples/sequence_module.R">sequence_module.R</a>
contains several functions calculating terms of mathematical sequences.
It is possible to import from such files, just as one imports from
packages:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(sequence_module.R, fibonacci, square, triangular)</span></code></pre></div>
<p>Renaming, the <code>.all</code>, and the <code>.except</code>
parameters work in the same way as for packages:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(sequence_module.R, <span class="at">fib=</span>fibonacci, <span class="at">.except=</span><span class="st">&quot;square&quot;</span>)</span></code></pre></div>
<p>If a module is modified, <code>import</code> will realize this and
reload the script if further imports are executed or re-executed;
otherwise additional imports will not cause the script to be reloaded
for efficiency. As the script is loaded in its own environment
(maintained by <code>import</code>) dependencies are kept (except those
exposed through attachment), as the following small example shows.</p>
<p><strong>Contents of “<a href="https://raw.githubusercontent.com/rticulate/import/master/man/examples/some_module.R">some_module.R</a>”:</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="do">## Do not use library() inside a module. This results in a warning, </span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="do">## and functions relying on ggplot2 will not work.</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="co">#library(ggplot2)</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="do">## This is also not recommended, because it is not clear wether recursively </span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="do">## imported functions should be available after the module is imported</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">#import::here(qplot, .from = ggplot2)</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="do">## This is the recommended way to recursively import functions on which</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a><span class="do">## module functions depend. The qplot function will be available to </span></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a><span class="do">## module functions, but will not itself be available after import</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">here</span>(qplot, <span class="at">.from =</span> ggplot2)</span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a><span class="do">## Note this operator overload is not something you want to `source`!</span></span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a><span class="st">`</span><span class="at">+</span><span class="st">`</span> <span class="ot">&lt;-</span> <span class="cf">function</span>(e1, e2)</span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a>  <span class="fu">paste</span>(e1, e2)</span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a><span class="do">## Some function relying on the above overload:</span></span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="cf">function</span>(s1, s2)</span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>  s1 <span class="sc">+</span> <span class="fu">rep</span>(s2, <span class="dv">3</span>)</span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a><span class="do">## Another value.</span></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">head</span>(iris, <span class="dv">10</span>)</span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a></span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a><span class="do">## A value created using a recursively imported function</span></span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">qplot</span>(Sepal.Length, Sepal.Width, <span class="at">data =</span> iris, <span class="at">color =</span> Species)</span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a></span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a><span class="do">## A function relying on a function exposed through attachment:</span></span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a>plot_it <span class="ot">&lt;-</span> <span class="cf">function</span>()</span>
<span id="cb10-30"><a href="#cb10-30" tabindex="-1"></a>  <span class="fu">qplot</span>(Sepal.Length, Sepal.Width, <span class="at">data =</span> iris, <span class="at">color =</span> Species)</span></code></pre></div>
<p><strong>Usage:</strong></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(some_module.R, a, b, p, plot_it)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="do">## Works:</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="fu">a</span>(<span class="st">&quot;cool&quot;</span>, <span class="st">&quot;import&quot;</span>)</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="do">## The `+` is not affecting anything here, so this won&#39;t work:</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="co"># &quot;cool&quot; + &quot;import&quot;</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a><span class="co"># Works:</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>b</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>p</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a><span class="fu">plot_it</span>()</span></code></pre></div>
<p>Suppose that you have some related functionality that you wish to
bundle, and that authoring a full package seems excessive or
inappropriate for the specific task, for example bundling related user
interface components for a <code>shiny</code> application. One option
with <code>import</code> is to author a module (script), say as outlined
below:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="co"># File: foo.R</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="co"># Desc: Functionality related to foos.</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co"># Imports from other_resources.R</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co"># When recursively importing from another module or package for use by </span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="co"># your module functions, you should always use import::here() rather </span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="co"># than import::from() or library()</span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">here</span>(fun_a, fun_b, <span class="at">.from =</span> <span class="st">&quot;other_resources.R&quot;</span>)</span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>internal_fun <span class="ot">&lt;-</span> <span class="cf">function</span>(...) ...</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>fun_c <span class="ot">&lt;-</span> <span class="cf">function</span>(...) </span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a>{</span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>  ...</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>  a <span class="ot">&lt;-</span> <span class="fu">fun_a</span>(...)</span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a>  i <span class="ot">&lt;-</span> <span class="fu">internal_fun</span>(...)</span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a>  ...</span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a>}</span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" tabindex="-1"></a>fun_d <span class="ot">&lt;-</span> <span class="cf">function</span>(...) ...</span></code></pre></div>
<p>Then in another file we need <code>fun_c</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co"># File: bar.R</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="co"># Desc: Functionality related to bars. </span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co"># Imports from foo.R</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">here</span>(fun_c, <span class="at">.from =</span> <span class="st">&quot;foo.R&quot;</span>)</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>...</span></code></pre></div>
<p>In the above, <em>only</em> <code>fun_c</code> is visible inside
<code>bar.R</code>. The functions on which it depends exist, but are not
exposed. Also, note that imported scripts may themselves import.</p>
<p>Since the desired effect of <code>import::from</code> inside a module
script is ambiguous, this results in a warning (but the functions will
still be imported into the local environment of the script, just as with
<code>import::here</code> which only imports are only exposed to the
module itself.</p>
<p>When importing from a module, it is sourced into an environment
managed by <code>import</code>, and will not be sourced again upon
subsequent imports (unless the file has changed). For example, in a
<code>shiny</code> application, importing some objects in
<code>server.R</code> and others in <code>ui.R</code> from the same
module will not cause it to be sourced twice.</p>
</div>
<div id="choosing-where-import-looks-for-packages-or-modules" class="section level3">
<h3>Choosing where import looks for packages or modules</h3>
<p>The <code>import</code> package will by default use the current set
of library paths, i.e. the result of <code>.libPaths()</code>. It is,
however, possible to specify a different set of library paths using the
<code>.library</code> argument in any of the <code>import</code>
functions, for example to import packages installed in a custom
location, or to remove any ambiguity as to where imports come from.</p>
<p>Note that in versions up to and including <code>1.3.0</code> this
defaulted to use only the <em>first</em> entry in the library paths,
i.e. <code>.library=.libPaths()[1L]</code>. We believe the new default
is applicable in a broader set of circumstances, but if this change
causes any issues, we would very much appreciate hearing about it.</p>
<p>When importing from a module (.R file), the directory where
<code>import</code> looks for the module script can be specified with
the with <code>.directory</code> parameter. The default is
<code>.</code> (the current working directory).</p>
</div>
<div id="choosing-where-the-imported-functions-are-placed" class="section level3">
<h3>Choosing where the imported functions are placed</h3>
<p>One can also specify which names to use in the search path and use
several to group imports. Names can be specified either as character
literals or as variables of type <code>character</code> (for example if
the environment needs to be determined dynamically).</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(magrittr, <span class="st">&quot;%&gt;%&quot;</span>, <span class="st">&quot;%$%&quot;</span>, <span class="at">.into =</span> <span class="st">&quot;operators&quot;</span>)</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(dplyr, arrange, <span class="at">.into =</span> <span class="st">&quot;datatools&quot;</span>)</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(psych, describe, <span class="at">.into=</span>month.name[<span class="dv">1</span>]) <span class="co"># Uses env: &quot;January&quot;</span></span></code></pre></div>
<p>The <code>import::into</code> and <code>import::from</code> accept
the same parameters and achieve the same result. The the choice between
them a matter of preference). If using custom search path entities
actively, one might prefer the alternative syntax (which does the same
but reverses the argument order):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">into</span>(<span class="st">&quot;operators&quot;</span>, <span class="st">&quot;%&gt;%&quot;</span>, <span class="st">&quot;%$%&quot;</span>, <span class="at">.from =</span> magrittr)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">into</span>(<span class="st">&quot;datatools&quot;</span>, arrange, <span class="at">.from =</span> dplyr)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">into</span>(month.name[<span class="dv">1</span>], describe, <span class="at">.from=</span>psych)</span></code></pre></div>
<p>Be aware that beginning in version <code>1.3.0</code> hidden objects
(those with names prefixed by a period) are supported. Take care to
avoid name clashes with argument names.</p>
<p>If it is desired to import objects directly into the current
environment, this can be accomplished by <code>import::here</code>. This
is particularly useful when importing inside a function definition, or
module scripts as described <a href="#module">here</a>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">here</span>(<span class="st">&quot;%&gt;%&quot;</span>, <span class="st">&quot;%$%&quot;</span>, <span class="at">.from =</span> magrittr)</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">here</span>(arrange, <span class="at">.from =</span> dplyr)</span></code></pre></div>
<p>Instead of specifying a named environment on the search path, by
passing a <code>character</code> to the <code>.into</code> parameter, it
is possible to directly specify an environment. The function
automatically determines which use case is involved, based on the
<code>mode()</code> of the <code>.into</code> parameter (either
<code>character</code> or <code>environment</code>).</p>
<p>Prior to version <code>1.3.0</code>, non-standard evaluation (NSE)
was applied to the <code>.into</code> parameter, and it was necessary to
surround it with <code>{}</code>, in order for it to be treated as an
<code>environment</code>. This is no longer needed, although it is still
allowed (curly brackets are simply ignored).</p>
<p>Examples include:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="co"># Import into the local environment</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">into</span>(<span class="fu">environment</span>(), <span class="st">&quot;%&gt;%&quot;</span>, <span class="at">.from =</span> magrittr)</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="co"># Import into the global environment, curlies are optional</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">into</span>({.GlobalEnv}, <span class="st">&quot;%&gt;%&quot;</span>, <span class="st">&quot;%$%&quot;</span>, <span class="at">.from =</span> magrittr)</span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a><span class="co"># Import into a new environment, mainly useful for python-style imports</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a><span class="co"># (see below)</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a>x <span class="ot">=</span> import<span class="sc">::</span><span class="fu">into</span>(<span class="fu">new.env</span>(), <span class="st">&quot;%&lt;&gt;%&quot;</span>, <span class="at">.from =</span> magrittr)</span></code></pre></div>
</div>
</div>
</div>
<div id="advanced-usage" class="section level1">
<h1>Advanced usage</h1>
<div id="advanced-usage-and-the-.character_only-parameter" class="section level2">
<h2>Advanced usage and the .character_only parameter</h2>
<p>The <code>import</code> package uses non-standard evaluation (NSE) on
the <code>.from</code> and <code>...</code> parameters, allowing the
names of packages and functions to be listed without quoting them. This
makes some common use-cases very straightforward, but can get in the way
of more programmatic usages.</p>
<p>This is where the <code>.character_only</code> parameter comes in
handy. By setting <code>.character_only=TRUE</code>, the non-standard
evaluation of the <code>.from</code> and the <code>...</code> parameters
is disabled. Instead, the parameters are processed as character vectors
containing the relevant values.</p>
<p>(Previously, NSE was also applied to the <code>.into</code>
parameter, but as of version <code>1.3.0</code> this is no longer the
case, and all parameters except <code>.from</code> and <code>...</code>
are always evaluated in a standard way.)</p>
<p>It is useful to examine some examples of how specifying
<code>.character_only=TRUE</code> can be helpful.</p>
</div>
<div id="programmatic-selection-of-objects-to-import" class="section level2">
<h2>Programmatic selection of objects to import</h2>
<p>It is not always know in advance which objects to import from a given
package. For example, assume we have a list of objects from the
<code>broom</code> package that we need to import, we can do it as
follows:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>objects <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;tidy&quot;</span>, <span class="st">&quot;glance&quot;</span>, <span class="st">&quot;augment&quot;</span>)</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(<span class="st">&quot;broom&quot;</span>, objects, <span class="at">.character_only=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p>This will import the three functions specified in the
<code>objects</code> vector. It is worth noting that because
<code>.character_only</code> disables non-standard evaluation on
<em>all</em> parameters, the name of the package must now be quoted.</p>
<p>One common use case is when one wants to import all objects except
one or a few, because of conflicts with other packages. Should one, for
example, want to use the <code>stats</code> versions of the
<code>filter()</code> and <code>lag()</code> functions, but import all
the other functions in the <code>dplyr</code> package, one could do it
like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>objects <span class="ot">&lt;-</span> <span class="fu">setdiff</span>(<span class="fu">getNamespaceExports</span>(<span class="st">&quot;dplyr&quot;</span>), <span class="fu">c</span>(<span class="st">&quot;filter&quot;</span>,<span class="st">&quot;lag&quot;</span>))</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(<span class="st">&quot;dplyr&quot;</span>, objects, <span class="at">.character_only=</span><span class="cn">TRUE</span>)</span></code></pre></div>
</div>
<div id="programmatic-selection-of-module-location" class="section level2">
<h2>Programmatic selection of module location</h2>
<p>The same approach can be used when the directory of the source file
for a module is not known in advance. This can be useful when the
original source file is not always run with the original working
directory, but one still does not want to specify a hard-coded absolute
path, but to determine it at run time:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>mymodule <span class="ot">&lt;-</span> <span class="fu">file.path</span>(mypath, <span class="st">&quot;module.R&quot;</span>)</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(mymodule, <span class="st">&quot;myfunction&quot;</span>, <span class="at">.character_only=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p>Again, note that now the name of the function must be quoted because
non-standard evaluation is disabled on all parameters.</p>
<p>The <code>here</code> package is useful in many circumstances like
this; it allows the setting of a “root” directory for a project and by
using the <code>here::here()</code> function to figure out the correct
directory, regardless of the working directory.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(here<span class="sc">::</span><span class="fu">here</span>(<span class="st">&quot;src/utils/module.R&quot;</span>)), <span class="st">&quot;myfunction&quot;</span>, .character_only<span class="ot">=</span><span class="cn">TRUE</span><span class="er">)</span></span></code></pre></div>
<p>Alternatively, if the file name is always the same and it is only the
directory that differs, you could use the <code>.directory</code>
parameter, which always expects standard evaluation arguments.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(module.R, <span class="st">&quot;myfunction&quot;</span>, here<span class="sc">::</span><span class="fu">here</span>(<span class="st">&quot;src/utils&quot;</span>))</span></code></pre></div>
<p>Note that <code>here::here()</code> has no relation to
<code>import::here()</code> despite the similarity in names.</p>
</div>
<div id="importing-from-a-url" class="section level2">
<h2>Importing from a URL</h2>
<p>Another case where <code>.character_only</code> comes in handy is
when one wants to import some functions from a URL. While
<code>import</code> does not allow direct importing from a URL (because
of difficult questions about when a URL target has changes, whether to
download a file and other things), it easy to achieve the desired result
by using the <code>pins</code> package (whose main purpose is to resolve
such difficult questions). A simple example follows, which directly
imports the <code>myfunc()</code> function, which is defined in the <a href="https://raw.githubusercontent.com/rticulate/import/master/man/examples/plusone_module.R"><code>plusone_module.R</code></a>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="st">&quot;https://raw.githubusercontent.com/rticulate/import/master/man/examples/plusone_module.R&quot;</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(pins<span class="sc">::</span><span class="fu">pin</span>(url), <span class="st">&quot;myfunc&quot;</span>, <span class="at">.character_only=</span><span class="cn">TRUE</span>)</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a><span class="fu">myfunc</span>(<span class="dv">3</span>)</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a><span class="co">#&gt; [1] 4</span></span></code></pre></div>
</div>
<div id="python-like-imports" class="section level2">
<h2>Python-like imports</h2>
<p>A frequent pattern in python imports packages under an alias; all
subsequent use of the imported objects then explicitly includes the
alias:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a><span class="im">import</span> math <span class="im">as</span> m</span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a><span class="bu">print</span>(m.pi)</span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a><span class="bu">print</span>(m.e)</span></code></pre></div>
<p>In order to achieve this functionality with the import package, use
<code>.into={new.env()}</code> which assign to a new environment without
attaching it. <code>import::from()</code> returns this environment, so
it can be assigned to a variable:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="co"># Import into a new namespace, use $ to access</span></span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>td <span class="ot">&lt;-</span> import<span class="sc">::</span><span class="fu">from</span>(tidyr, spread, pivot_wider, <span class="at">.into=</span>{<span class="fu">new.env</span>()})</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>dp <span class="ot">&lt;-</span> import<span class="sc">::</span><span class="fu">from</span>(dplyr, <span class="at">.all=</span><span class="cn">TRUE</span>, <span class="at">.into=</span>{<span class="fu">new.env</span>()})</span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>dp<span class="sc">$</span><span class="fu">select</span>(<span class="fu">head</span>(cars),dist)</span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a><span class="co">#&gt;   dist</span></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a><span class="co">#&gt; 1    2</span></span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a><span class="co">#&gt; 2   10</span></span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a><span class="co">#&gt; 3    4</span></span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a><span class="co">#&gt; 4   22</span></span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a><span class="co">#&gt; 5   16</span></span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a><span class="co">#&gt; 6   10</span></span>
<span id="cb25-12"><a href="#cb25-12" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" tabindex="-1"></a><span class="co"># Note that functions are not visible without dp$ prefix</span></span>
<span id="cb25-14"><a href="#cb25-14" tabindex="-1"></a><span class="fu">select</span>(<span class="fu">head</span>(cars),dist)</span>
<span id="cb25-15"><a href="#cb25-15" tabindex="-1"></a><span class="co">#&gt; Error in select(head(cars), dist): could not find function &quot;select&quot;</span></span></code></pre></div>
</div>
<div id="importing-s3-methods" class="section level2">
<h2>Importing S3 methods</h2>
<p><img role="img" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTM2IiBoZWlnaHQ9IjIwIj48bGluZWFyR3JhZGllbnQgaWQ9ImIiIHgyPSIwIiB5Mj0iMTAwJSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjYmJiIiBzdG9wLW9wYWNpdHk9Ii4xIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLW9wYWNpdHk9Ii4xIi8+PC9saW5lYXJHcmFkaWVudD48Y2xpcFBhdGggaWQ9ImEiPjxyZWN0IHdpZHRoPSIxMzYiIGhlaWdodD0iMjAiIHJ4PSIzIiBmaWxsPSIjZmZmIi8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjYSkiPjxwYXRoIGZpbGw9IiM1NTUiIGQ9Ik0wIDBoNTN2MjBIMHoiLz48cGF0aCBmaWxsPSIjZmU3ZDM3IiBkPSJNNTMgMGg4M3YyMEg1M3oiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMCAwaDEzNnYyMEgweiIvPjwvZz48ZyBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0iRGVqYVZ1IFNhbnMsVmVyZGFuYSxHZW5ldmEsc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMTAiPjx0ZXh0IHg9IjI3NSIgeT0iMTUwIiBmaWxsPSIjMDEwMTAxIiBmaWxsLW9wYWNpdHk9Ii4zIiB0cmFuc2Zvcm09InNjYWxlKC4xKSIgdGV4dExlbmd0aD0iNDMwIj5saWZlY3ljbGU8L3RleHQ+PHRleHQgeD0iMjc1IiB5PSIxNDAiIHRyYW5zZm9ybT0ic2NhbGUoLjEpIiB0ZXh0TGVuZ3RoPSI0MzAiPmxpZmVjeWNsZTwvdGV4dD48dGV4dCB4PSI5MzUiIHk9IjE1MCIgZmlsbD0iIzAxMDEwMSIgZmlsbC1vcGFjaXR5PSIuMyIgdHJhbnNmb3JtPSJzY2FsZSguMSkiIHRleHRMZW5ndGg9IjczMCI+ZXhwZXJpbWVudGFsPC90ZXh0Pjx0ZXh0IHg9IjkzNSIgeT0iMTQwIiB0cmFuc2Zvcm09InNjYWxlKC4xKSIgdGV4dExlbmd0aD0iNzMwIj5leHBlcmltZW50YWw8L3RleHQ+PC9nPiA8L3N2Zz4=" /></p>
<p>S3 methods work well in local context, but when the method is called
from a different environment, it must be registered (in packages, this
is done in the <code>NAMESPACE</code> file). <code>import</code> can now
register methods of form <code>generic.class</code> or
<code>generic.class.name</code> automatically using the new
<code>.S3</code> argument. By specifying <code>.S3=TRUE</code>,
<code>import</code> will automatically detect methods for existing or
new generics. No need to export and/or register them manually!</p>
<p>Consider following script <code>foo.r</code> with a generic and two
methods:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="co"># foo.r</span></span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a><span class="co"># functions with great foonctionality</span></span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a>foo <span class="ot">=</span> <span class="cf">function</span>(x){</span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a>  <span class="fu">UseMethod</span>(<span class="st">&quot;foo&quot;</span>, x)</span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a>}</span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a>foo.numeric <span class="ot">&lt;-</span> <span class="cf">function</span>(x){</span>
<span id="cb26-8"><a href="#cb26-8" tabindex="-1"></a>  x <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb26-9"><a href="#cb26-9" tabindex="-1"></a>}</span>
<span id="cb26-10"><a href="#cb26-10" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" tabindex="-1"></a>foo.character <span class="ot">&lt;-</span> <span class="cf">function</span>(x){</span>
<span id="cb26-12"><a href="#cb26-12" tabindex="-1"></a>  <span class="fu">paste0</span>(<span class="st">&quot;_&quot;</span>, x, <span class="st">&quot;_&quot;</span>)</span>
<span id="cb26-13"><a href="#cb26-13" tabindex="-1"></a>}</span></code></pre></div>
<p>Now, all we need is to import the <code>foo</code> generic:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>import<span class="sc">::</span><span class="fu">from</span>(<span class="st">&quot;foo.r&quot;</span>, foo, <span class="at">.S3=</span><span class="cn">TRUE</span>)</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a><span class="fu">foo</span>(<span class="dv">0</span>) <span class="co"># 1</span></span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a><span class="fu">foo</span>(<span class="st">&quot;bar&quot;</span>) <span class="co"># _bar_</span></span></code></pre></div>
<p><em>This is an experimental feature. We think it should work well and
you are encouraged to use it and report back – but the syntax and
semantics may change in the future to improve the feature.</em></p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
